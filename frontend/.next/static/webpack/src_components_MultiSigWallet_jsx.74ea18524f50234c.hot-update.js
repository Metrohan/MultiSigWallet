"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("src_components_MultiSigWallet_jsx",{

/***/ "./src/lib/contractCalls.js":
/*!**********************************!*\
  !*** ./src/lib/contractCalls.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   confirmTransaction: function() { return /* binding */ confirmTransaction; },\n/* harmony export */   getProposal: function() { return /* binding */ getProposal; },\n/* harmony export */   getProposals: function() { return /* binding */ getProposals; },\n/* harmony export */   getThreshold: function() { return /* binding */ getThreshold; },\n/* harmony export */   initializeContract: function() { return /* binding */ initializeContract; },\n/* harmony export */   isOwner: function() { return /* binding */ isOwner; },\n/* harmony export */   proposeTransaction: function() { return /* binding */ proposeTransaction; }\n/* harmony export */ });\n/* harmony import */ var _stacks_transactions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stacks/transactions */ \"./node_modules/@stacks/transactions/dist/polyfill/index.js\");\n/* harmony import */ var _stacks_network__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stacks/network */ \"./node_modules/@stacks/network/dist/esm/index.js\");\n/* harmony import */ var _stacks_connect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stacks/connect */ \"./node_modules/@stacks/connect/dist/index.mjs\");\n// src/lib/contractCalls.js\n\n\n\nconst contractAddress = \"ST396D69K21GVKQVKTGSVJ9J8GRF1A9N3NCFP69P7\"; // kendi adresin\nconst contractName = \"multi-sig-wallet\";\nconst network = new _stacks_network__WEBPACK_IMPORTED_MODULE_0__.StacksTestnet();\nconst proposeTransaction = async (recipient, amount)=>{\n    const integerAmount = Number(amount);\n    if (!Number.isInteger(integerAmount) || integerAmount <= 0) {\n        throw new Error(\"Amount must be a positive integer\");\n    }\n    const functionArgs = [\n        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.standardPrincipalCV)(recipient),\n        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.uintCV)(integerAmount)\n    ];\n    const options = {\n        contractAddress,\n        contractName,\n        functionName: \"propose-transaction\",\n        functionArgs,\n        network,\n        postConditionMode: _stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.PostConditionMode.Allow,\n        onFinish: (data)=>console.log(\"Transaction submitted:\", data),\n        onCancel: ()=>console.log(\"Transaction canceled\")\n    };\n    await (0,_stacks_connect__WEBPACK_IMPORTED_MODULE_2__.openContractCall)(options);\n};\nconst confirmTransaction = async (proposalId)=>{\n    // Proposal ID validasyonu\n    if (!proposalId) {\n        throw new Error(\"Proposal ID is required\");\n    }\n    const parsedId = parseInt(proposalId);\n    if (isNaN(parsedId) || parsedId <= 0) {\n        throw new Error(\"Invalid proposal ID. Must be a positive number.\");\n    }\n    const functionArgs = [\n        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.uintCV)(parsedId)\n    ];\n    const options = {\n        contractAddress,\n        contractName,\n        functionName: \"confirm-transaction\",\n        functionArgs,\n        network,\n        postConditionMode: _stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.PostConditionMode.Allow,\n        onFinish: (data)=>console.log(\"Transaction submitted:\", data),\n        onCancel: ()=>console.log(\"Transaction canceled\")\n    };\n    await (0,_stacks_connect__WEBPACK_IMPORTED_MODULE_2__.openContractCall)(options);\n};\n// Contract'ınızın yapısına uygun olarak güncellenmiş getProposals fonksiyonu\nconst getProposals = async (sender)=>{\n    try {\n        // Önce toplam proposal sayısını al\n        const countResult = await (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.callReadOnlyFunction)({\n            contractAddress,\n            contractName,\n            functionName: \"get-proposal-count\",\n            functionArgs: [],\n            network,\n            senderAddress: sender\n        });\n        const totalCount = parseInt(countResult.value.value);\n        const proposals = [];\n        // Her proposal'ı tek tek çek (1'den başlayarak çünkü ID'ler 1'den başlıyor)\n        for(let i = 1; i <= totalCount; i++){\n            try {\n                const proposalResult = await (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.callReadOnlyFunction)({\n                    contractAddress,\n                    contractName,\n                    functionName: \"get-proposal\",\n                    functionArgs: [\n                        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.uintCV)(i)\n                    ],\n                    network,\n                    senderAddress: sender\n                });\n                // Proposal varsa listeye ekle\n                if (proposalResult.value !== null && proposalResult.value.data) {\n                    const proposalData = proposalResult.value.data;\n                    proposals.push({\n                        id: i,\n                        recipient: proposalData.to.value,\n                        amount: parseInt(proposalData.amount.value) / 1000000,\n                        confirmationCount: parseInt(proposalData[\"confirmation-count\"].value),\n                        executed: proposalData.executed.value,\n                        confirmations: proposalData.confirmations.value.map((p)=>p.value)\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error fetching proposal \".concat(i, \":\"), error);\n            // Belirli bir proposal alınamıyorsa devam et\n            }\n        }\n        return proposals;\n    } catch (error) {\n        console.error(\"Error fetching proposals:\", error);\n        return [];\n    }\n};\n// Tek bir proposal almak için yardımcı fonksiyon\nconst getProposal = async (proposalId, sender)=>{\n    try {\n        const result = await (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.callReadOnlyFunction)({\n            contractAddress,\n            contractName,\n            functionName: \"get-proposal\",\n            functionArgs: [\n                (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.uintCV)(parseInt(proposalId))\n            ],\n            network,\n            senderAddress: sender\n        });\n        if (result.value && result.value.data) {\n            const proposalData = result.value.data;\n            return {\n                id: parseInt(proposalId),\n                recipient: proposalData.to.value,\n                amount: parseInt(proposalData.amount.value) / 1000000,\n                confirmationCount: parseInt(proposalData[\"confirmation-count\"].value),\n                executed: proposalData.executed.value,\n                confirmations: proposalData.confirmations.value.map((p)=>p.value)\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error fetching proposal:\", error);\n        return null;\n    }\n};\n// Threshold'u almak için yardımcı fonksiyon\nconst getThreshold = async (sender)=>{\n    try {\n        const result = await (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.callReadOnlyFunction)({\n            contractAddress,\n            contractName,\n            functionName: \"get-threshold\",\n            functionArgs: [],\n            network,\n            senderAddress: sender\n        });\n        return parseInt(result.value.value);\n    } catch (error) {\n        console.error(\"Error fetching threshold:\", error);\n        return 0;\n    }\n};\n// Contract'ı initialize etmek için\nconst initializeContract = async (owner1, owner2, owner3, threshold)=>{\n    const functionArgs = [\n        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.standardPrincipalCV)(owner1),\n        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.standardPrincipalCV)(owner2),\n        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.standardPrincipalCV)(owner3),\n        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.uintCV)(threshold)\n    ];\n    const options = {\n        contractAddress,\n        contractName,\n        functionName: \"initialize\",\n        functionArgs,\n        network,\n        postConditionMode: _stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.PostConditionMode.Allow,\n        onFinish: (data)=>console.log(\"Initialize transaction submitted:\", data),\n        onCancel: ()=>console.log(\"Initialize transaction canceled\")\n    };\n    await (0,_stacks_connect__WEBPACK_IMPORTED_MODULE_2__.openContractCall)(options);\n};\nconst isOwner = async (principalAddress, sender)=>{\n    try {\n        var _result_value;\n        const result = await (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.callReadOnlyFunction)({\n            contractAddress,\n            contractName,\n            functionName: \"is-owner-check\",\n            functionArgs: [\n                (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.standardPrincipalCV)(principalAddress)\n            ],\n            network,\n            senderAddress: sender\n        });\n        return (result === null || result === void 0 ? void 0 : (_result_value = result.value) === null || _result_value === void 0 ? void 0 : _result_value.value) === true;\n    } catch (error) {\n        console.error(\"Error checking owner status:\", error);\n        return false;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Y0FBYmUsb0NBQUFBLGNBQWVmLEtBQUssTUFBSztJQUNsQyxFQUFFLE9BQU9hLE9BQU87UUFDZDFCLFFBQVEwQixLQUFLLENBQUMsZ0NBQWdDQTtRQUM5QyxPQUFPO0lBQ1Q7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvY29udHJhY3RDYWxscy5qcz9jMmJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9saWIvY29udHJhY3RDYWxscy5qc1xyXG5pbXBvcnQge1xyXG4gIGNhbGxSZWFkT25seUZ1bmN0aW9uLFxyXG4gIHN0YW5kYXJkUHJpbmNpcGFsQ1YsXHJcbiAgdWludENWLFxyXG4gIHN0cmluZ1V0ZjhDVixcclxuICBQb3N0Q29uZGl0aW9uTW9kZSxcclxufSBmcm9tICdAc3RhY2tzL3RyYW5zYWN0aW9ucyc7XHJcbmltcG9ydCB7IFN0YWNrc1Rlc3RuZXQgfSBmcm9tICdAc3RhY2tzL25ldHdvcmsnO1xyXG5pbXBvcnQgeyBvcGVuQ29udHJhY3RDYWxsIH0gZnJvbSAnQHN0YWNrcy9jb25uZWN0JztcclxuXHJcbmNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IFwiU1QzOTZENjlLMjFHVktRVktUR1NWSjlKOEdSRjFBOU4zTkNGUDY5UDdcIjsgLy8ga2VuZGkgYWRyZXNpblxyXG5jb25zdCBjb250cmFjdE5hbWUgPSBcIm11bHRpLXNpZy13YWxsZXRcIjtcclxuY29uc3QgbmV0d29yayA9IG5ldyBTdGFja3NUZXN0bmV0KCk7XHJcblxyXG5leHBvcnQgY29uc3QgcHJvcG9zZVRyYW5zYWN0aW9uID0gYXN5bmMgKHJlY2lwaWVudCwgYW1vdW50KSA9PiB7XHJcbiAgY29uc3QgaW50ZWdlckFtb3VudCA9IE51bWJlcihhbW91bnQpO1xyXG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihpbnRlZ2VyQW1vdW50KSB8fCBpbnRlZ2VyQW1vdW50IDw9IDApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkFtb3VudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcclxuICB9XHJcbiAgXHJcbiAgY29uc3QgZnVuY3Rpb25BcmdzID0gW1xyXG4gICAgc3RhbmRhcmRQcmluY2lwYWxDVihyZWNpcGllbnQpLFxyXG4gICAgdWludENWKGludGVnZXJBbW91bnQpXHJcbiAgXTtcclxuICBcclxuICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgY29udHJhY3RBZGRyZXNzLFxyXG4gICAgY29udHJhY3ROYW1lLFxyXG4gICAgZnVuY3Rpb25OYW1lOiBcInByb3Bvc2UtdHJhbnNhY3Rpb25cIixcclxuICAgIGZ1bmN0aW9uQXJncyxcclxuICAgIG5ldHdvcmssXHJcbiAgICBwb3N0Q29uZGl0aW9uTW9kZTogUG9zdENvbmRpdGlvbk1vZGUuQWxsb3csXHJcbiAgICBvbkZpbmlzaDogZGF0YSA9PiBjb25zb2xlLmxvZygnVHJhbnNhY3Rpb24gc3VibWl0dGVkOicsIGRhdGEpLFxyXG4gICAgb25DYW5jZWw6ICgpID0+IGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBjYW5jZWxlZCcpXHJcbiAgfTtcclxuICBcclxuICBhd2FpdCBvcGVuQ29udHJhY3RDYWxsKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbmZpcm1UcmFuc2FjdGlvbiA9IGFzeW5jIChwcm9wb3NhbElkKSA9PiB7XHJcbiAgLy8gUHJvcG9zYWwgSUQgdmFsaWRhc3lvbnVcclxuICBpZiAoIXByb3Bvc2FsSWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIlByb3Bvc2FsIElEIGlzIHJlcXVpcmVkXCIpO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBwYXJzZWRJZCA9IHBhcnNlSW50KHByb3Bvc2FsSWQpO1xyXG4gIGlmIChpc05hTihwYXJzZWRJZCkgfHwgcGFyc2VkSWQgPD0gMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9wb3NhbCBJRC4gTXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlci5cIik7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IGZ1bmN0aW9uQXJncyA9IFt1aW50Q1YocGFyc2VkSWQpXTtcclxuICBcclxuICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgY29udHJhY3RBZGRyZXNzLFxyXG4gICAgY29udHJhY3ROYW1lLFxyXG4gICAgZnVuY3Rpb25OYW1lOiBcImNvbmZpcm0tdHJhbnNhY3Rpb25cIixcclxuICAgIGZ1bmN0aW9uQXJncyxcclxuICAgIG5ldHdvcmssXHJcbiAgICBwb3N0Q29uZGl0aW9uTW9kZTogUG9zdENvbmRpdGlvbk1vZGUuQWxsb3csXHJcbiAgICBvbkZpbmlzaDogZGF0YSA9PiBjb25zb2xlLmxvZygnVHJhbnNhY3Rpb24gc3VibWl0dGVkOicsIGRhdGEpLFxyXG4gICAgb25DYW5jZWw6ICgpID0+IGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBjYW5jZWxlZCcpXHJcbiAgfTtcclxuICBcclxuICBhd2FpdCBvcGVuQ29udHJhY3RDYWxsKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLy8gQ29udHJhY3QnxLFuxLF6xLFuIHlhcMSxc8SxbmEgdXlndW4gb2xhcmFrIGfDvG5jZWxsZW5tacWfIGdldFByb3Bvc2FscyBmb25rc2l5b251XHJcbmV4cG9ydCBjb25zdCBnZXRQcm9wb3NhbHMgPSBhc3luYyAoc2VuZGVyKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIMOWbmNlIHRvcGxhbSBwcm9wb3NhbCBzYXnEsXPEsW7EsSBhbFxyXG4gICAgY29uc3QgY291bnRSZXN1bHQgPSBhd2FpdCBjYWxsUmVhZE9ubHlGdW5jdGlvbih7XHJcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgY29udHJhY3ROYW1lLFxyXG4gICAgICBmdW5jdGlvbk5hbWU6IFwiZ2V0LXByb3Bvc2FsLWNvdW50XCIsXHJcbiAgICAgIGZ1bmN0aW9uQXJnczogW10sXHJcbiAgICAgIG5ldHdvcmssXHJcbiAgICAgIHNlbmRlckFkZHJlc3M6IHNlbmRlcixcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBjb25zdCB0b3RhbENvdW50ID0gcGFyc2VJbnQoY291bnRSZXN1bHQudmFsdWUudmFsdWUpO1xyXG4gICAgY29uc3QgcHJvcG9zYWxzID0gW107XHJcbiAgICBcclxuICAgIC8vIEhlciBwcm9wb3NhbCfEsSB0ZWsgdGVrIMOnZWsgKDEnZGVuIGJhxZ9sYXlhcmFrIMOnw7xua8O8IElEJ2xlciAxJ2RlbiBiYcWfbMSxeW9yKVxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdG90YWxDb3VudDsgaSsrKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcHJvcG9zYWxSZXN1bHQgPSBhd2FpdCBjYWxsUmVhZE9ubHlGdW5jdGlvbih7XHJcbiAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgICBjb250cmFjdE5hbWUsXHJcbiAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwiZ2V0LXByb3Bvc2FsXCIsXHJcbiAgICAgICAgICBmdW5jdGlvbkFyZ3M6IFt1aW50Q1YoaSldLFxyXG4gICAgICAgICAgbmV0d29yayxcclxuICAgICAgICAgIHNlbmRlckFkZHJlc3M6IHNlbmRlcixcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBQcm9wb3NhbCB2YXJzYSBsaXN0ZXllIGVrbGVcclxuICAgICAgICBpZiAocHJvcG9zYWxSZXN1bHQudmFsdWUgIT09IG51bGwgJiYgcHJvcG9zYWxSZXN1bHQudmFsdWUuZGF0YSkge1xyXG4gICAgICAgICAgY29uc3QgcHJvcG9zYWxEYXRhID0gcHJvcG9zYWxSZXN1bHQudmFsdWUuZGF0YTtcclxuICAgICAgICAgIHByb3Bvc2Fscy5wdXNoKHtcclxuICAgICAgICAgICAgaWQ6IGksXHJcbiAgICAgICAgICAgIHJlY2lwaWVudDogcHJvcG9zYWxEYXRhLnRvLnZhbHVlLFxyXG4gICAgICAgICAgICBhbW91bnQ6IHBhcnNlSW50KHByb3Bvc2FsRGF0YS5hbW91bnQudmFsdWUpIC8gMV8wMDBfMDAwLCAvLyBtaWNyb1NUWCDihpIgU1RYXHJcbiAgICAgICAgICAgIGNvbmZpcm1hdGlvbkNvdW50OiBwYXJzZUludChwcm9wb3NhbERhdGFbJ2NvbmZpcm1hdGlvbi1jb3VudCddLnZhbHVlKSxcclxuICAgICAgICAgICAgZXhlY3V0ZWQ6IHByb3Bvc2FsRGF0YS5leGVjdXRlZC52YWx1ZSxcclxuICAgICAgICAgICAgY29uZmlybWF0aW9uczogcHJvcG9zYWxEYXRhLmNvbmZpcm1hdGlvbnMudmFsdWUubWFwKHAgPT4gcC52YWx1ZSlcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBwcm9wb3NhbCAke2l9OmAsIGVycm9yKTtcclxuICAgICAgICAvLyBCZWxpcmxpIGJpciBwcm9wb3NhbCBhbMSxbmFtxLF5b3JzYSBkZXZhbSBldFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBwcm9wb3NhbHM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBwcm9wb3NhbHM6XCIsIGVycm9yKTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBUZWsgYmlyIHByb3Bvc2FsIGFsbWFrIGnDp2luIHlhcmTEsW1jxLEgZm9ua3NpeW9uXHJcbmV4cG9ydCBjb25zdCBnZXRQcm9wb3NhbCA9IGFzeW5jIChwcm9wb3NhbElkLCBzZW5kZXIpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbFJlYWRPbmx5RnVuY3Rpb24oe1xyXG4gICAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICAgIGNvbnRyYWN0TmFtZSxcclxuICAgICAgZnVuY3Rpb25OYW1lOiBcImdldC1wcm9wb3NhbFwiLFxyXG4gICAgICBmdW5jdGlvbkFyZ3M6IFt1aW50Q1YocGFyc2VJbnQocHJvcG9zYWxJZCkpXSxcclxuICAgICAgbmV0d29yayxcclxuICAgICAgc2VuZGVyQWRkcmVzczogc2VuZGVyLFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGlmIChyZXN1bHQudmFsdWUgJiYgcmVzdWx0LnZhbHVlLmRhdGEpIHtcclxuICAgICAgY29uc3QgcHJvcG9zYWxEYXRhID0gcmVzdWx0LnZhbHVlLmRhdGE7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IHBhcnNlSW50KHByb3Bvc2FsSWQpLFxyXG4gICAgICAgIHJlY2lwaWVudDogcHJvcG9zYWxEYXRhLnRvLnZhbHVlLFxyXG4gICAgICAgIGFtb3VudDogcGFyc2VJbnQocHJvcG9zYWxEYXRhLmFtb3VudC52YWx1ZSkgLyAxXzAwMF8wMDAsXHJcbiAgICAgICAgY29uZmlybWF0aW9uQ291bnQ6IHBhcnNlSW50KHByb3Bvc2FsRGF0YVsnY29uZmlybWF0aW9uLWNvdW50J10udmFsdWUpLFxyXG4gICAgICAgIGV4ZWN1dGVkOiBwcm9wb3NhbERhdGEuZXhlY3V0ZWQudmFsdWUsXHJcbiAgICAgICAgY29uZmlybWF0aW9uczogcHJvcG9zYWxEYXRhLmNvbmZpcm1hdGlvbnMudmFsdWUubWFwKHAgPT4gcC52YWx1ZSlcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBwcm9wb3NhbDpcIiwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gVGhyZXNob2xkJ3UgYWxtYWsgacOnaW4geWFyZMSxbWPEsSBmb25rc2l5b25cclxuZXhwb3J0IGNvbnN0IGdldFRocmVzaG9sZCA9IGFzeW5jIChzZW5kZXIpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbFJlYWRPbmx5RnVuY3Rpb24oe1xyXG4gICAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICAgIGNvbnRyYWN0TmFtZSxcclxuICAgICAgZnVuY3Rpb25OYW1lOiBcImdldC10aHJlc2hvbGRcIixcclxuICAgICAgZnVuY3Rpb25BcmdzOiBbXSxcclxuICAgICAgbmV0d29yayxcclxuICAgICAgc2VuZGVyQWRkcmVzczogc2VuZGVyLFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBwYXJzZUludChyZXN1bHQudmFsdWUudmFsdWUpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgdGhyZXNob2xkOlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbn07XHJcblxyXG4vLyBDb250cmFjdCfEsSBpbml0aWFsaXplIGV0bWVrIGnDp2luXHJcbmV4cG9ydCBjb25zdCBpbml0aWFsaXplQ29udHJhY3QgPSBhc3luYyAob3duZXIxLCBvd25lcjIsIG93bmVyMywgdGhyZXNob2xkKSA9PiB7XHJcbiAgY29uc3QgZnVuY3Rpb25BcmdzID0gW1xyXG4gICAgc3RhbmRhcmRQcmluY2lwYWxDVihvd25lcjEpLFxyXG4gICAgc3RhbmRhcmRQcmluY2lwYWxDVihvd25lcjIpLFxyXG4gICAgc3RhbmRhcmRQcmluY2lwYWxDVihvd25lcjMpLFxyXG4gICAgdWludENWKHRocmVzaG9sZClcclxuICBdO1xyXG4gIFxyXG4gIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICBjb250cmFjdE5hbWUsXHJcbiAgICBmdW5jdGlvbk5hbWU6IFwiaW5pdGlhbGl6ZVwiLFxyXG4gICAgZnVuY3Rpb25BcmdzLFxyXG4gICAgbmV0d29yayxcclxuICAgIHBvc3RDb25kaXRpb25Nb2RlOiBQb3N0Q29uZGl0aW9uTW9kZS5BbGxvdyxcclxuICAgIG9uRmluaXNoOiBkYXRhID0+IGNvbnNvbGUubG9nKCdJbml0aWFsaXplIHRyYW5zYWN0aW9uIHN1Ym1pdHRlZDonLCBkYXRhKSxcclxuICAgIG9uQ2FuY2VsOiAoKSA9PiBjb25zb2xlLmxvZygnSW5pdGlhbGl6ZSB0cmFuc2FjdGlvbiBjYW5jZWxlZCcpXHJcbiAgfTtcclxuICBcclxuICBhd2FpdCBvcGVuQ29udHJhY3RDYWxsKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGlzT3duZXIgPSBhc3luYyAocHJpbmNpcGFsQWRkcmVzcywgc2VuZGVyKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbGxSZWFkT25seUZ1bmN0aW9uKHtcclxuICAgICAgY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICBjb250cmFjdE5hbWUsXHJcbiAgICAgIGZ1bmN0aW9uTmFtZTogXCJpcy1vd25lci1jaGVja1wiLFxyXG4gICAgICBmdW5jdGlvbkFyZ3M6IFtzdGFuZGFyZFByaW5jaXBhbENWKHByaW5jaXBhbEFkZHJlc3MpXSxcclxuICAgICAgbmV0d29yayxcclxuICAgICAgc2VuZGVyQWRkcmVzczogc2VuZGVyLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdD8udmFsdWU/LnZhbHVlID09PSB0cnVlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2hlY2tpbmcgb3duZXIgc3RhdHVzOlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG4iXSwibmFtZXMiOlsiY2FsbFJlYWRPbmx5RnVuY3Rpb24iLCJzdGFuZGFyZFByaW5jaXBhbENWIiwidWludENWIiwic3RyaW5nVXRmOENWIiwiUG9zdENvbmRpdGlvbk1vZGUiLCJTdGFja3NUZXN0bmV0Iiwib3BlbkNvbnRyYWN0Q2FsbCIsImNvbnRyYWN0QWRkcmVzcyIsImNvbnRyYWN0TmFtZSIsIm5ldHdvcmsiLCJwcm9wb3NlVHJhbnNhY3Rpb24iLCJyZWNpcGllbnQiLCJhbW91bnQiLCJpbnRlZ2VyQW1vdW50IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiRXJyb3IiLCJmdW5jdGlvbkFyZ3MiLCJvcHRpb25zIiwiZnVuY3Rpb25OYW1lIiwicG9zdENvbmRpdGlvbk1vZGUiLCJBbGxvdyIsIm9uRmluaXNoIiwiZGF0YSIsImNvbnNvbGUiLCJsb2ciLCJvbkNhbmNlbCIsImNvbmZpcm1UcmFuc2FjdGlvbiIsInByb3Bvc2FsSWQiLCJwYXJzZWRJZCIsInBhcnNlSW50IiwiaXNOYU4iLCJnZXRQcm9wb3NhbHMiLCJzZW5kZXIiLCJjb3VudFJlc3VsdCIsInNlbmRlckFkZHJlc3MiLCJ0b3RhbENvdW50IiwidmFsdWUiLCJwcm9wb3NhbHMiLCJpIiwicHJvcG9zYWxSZXN1bHQiLCJwcm9wb3NhbERhdGEiLCJwdXNoIiwiaWQiLCJ0byIsImNvbmZpcm1hdGlvbkNvdW50IiwiZXhlY3V0ZWQiLCJjb25maXJtYXRpb25zIiwibWFwIiwicCIsImVycm9yIiwiZ2V0UHJvcG9zYWwiLCJyZXN1bHQiLCJnZXRUaHJlc2hvbGQiLCJpbml0aWFsaXplQ29udHJhY3QiLCJvd25lcjEiLCJvd25lcjIiLCJvd25lcjMiLCJ0aHJlc2hvbGQiLCJpc093bmVyIiwicHJpbmNpcGFsQWRkcmVzcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/lib/contractCalls.js\n"));

/***/ })

});