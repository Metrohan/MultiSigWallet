"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("src_components_MultiSigWallet_jsx",{

/***/ "./src/lib/contractCalls.js":
/*!**********************************!*\
  !*** ./src/lib/contractCalls.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   confirmTransaction: function() { return /* binding */ confirmTransaction; },\n/* harmony export */   getProposal: function() { return /* binding */ getProposal; },\n/* harmony export */   getProposals: function() { return /* binding */ getProposals; },\n/* harmony export */   getThreshold: function() { return /* binding */ getThreshold; },\n/* harmony export */   initializeContract: function() { return /* binding */ initializeContract; },\n/* harmony export */   isOwner: function() { return /* binding */ isOwner; },\n/* harmony export */   proposeTransaction: function() { return /* binding */ proposeTransaction; }\n/* harmony export */ });\n/* harmony import */ var _stacks_transactions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stacks/transactions */ \"./node_modules/@stacks/transactions/dist/polyfill/index.js\");\n/* harmony import */ var _stacks_network__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stacks/network */ \"./node_modules/@stacks/network/dist/esm/index.js\");\n/* harmony import */ var _stacks_connect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stacks/connect */ \"./node_modules/@stacks/connect/dist/index.mjs\");\n// src/lib/contractCalls.js\n\n\n\nconst contractAddress = \"ST396D69K21GVKQVKTGSVJ9J8GRF1A9N3NCFP69P7\"; // kendi adresin\nconst contractName = \"multi-sig-wallet\";\nconst network = new _stacks_network__WEBPACK_IMPORTED_MODULE_0__.StacksTestnet();\nconst proposeTransaction = async (recipient, amount)=>{\n    const integerAmount = Number(amount);\n    if (!Number.isInteger(integerAmount) || integerAmount <= 0) {\n        throw new Error(\"Amount must be a positive integer\");\n    }\n    const functionArgs = [\n        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.standardPrincipalCV)(recipient),\n        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.uintCV)(integerAmount)\n    ];\n    const options = {\n        contractAddress,\n        contractName,\n        functionName: \"propose-transaction\",\n        functionArgs,\n        network,\n        postConditionMode: _stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.PostConditionMode.Allow,\n        onFinish: (data)=>console.log(\"Transaction submitted:\", data),\n        onCancel: ()=>console.log(\"Transaction canceled\")\n    };\n    await (0,_stacks_connect__WEBPACK_IMPORTED_MODULE_2__.openContractCall)(options);\n};\nconst confirmTransaction = async (proposalId)=>{\n    // Proposal ID validasyonu\n    if (!proposalId) {\n        throw new Error(\"Proposal ID is required\");\n    }\n    const parsedId = parseInt(proposalId);\n    if (isNaN(parsedId) || parsedId <= 0) {\n        throw new Error(\"Invalid proposal ID. Must be a positive number.\");\n    }\n    const functionArgs = [\n        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.uintCV)(parsedId)\n    ];\n    const options = {\n        contractAddress,\n        contractName,\n        functionName: \"confirm-transaction\",\n        functionArgs,\n        network,\n        postConditionMode: _stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.PostConditionMode.Allow,\n        onFinish: (data)=>console.log(\"Transaction submitted:\", data),\n        onCancel: ()=>console.log(\"Transaction canceled\")\n    };\n    await (0,_stacks_connect__WEBPACK_IMPORTED_MODULE_2__.openContractCall)(options);\n};\n// Contract'ınızın yapısına uygun olarak güncellenmiş getProposals fonksiyonu\nconst getProposals = async (sender)=>{\n    try {\n        // Önce toplam proposal sayısını al\n        const countResult = await (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.callReadOnlyFunction)({\n            contractAddress,\n            contractName,\n            functionName: \"get-proposal-count\",\n            functionArgs: [],\n            network,\n            senderAddress: sender\n        });\n        const totalCount = parseInt(countResult.value.value);\n        const proposals = [];\n        // Her proposal'ı tek tek çek (1'den başlayarak çünkü ID'ler 1'den başlıyor)\n        for(let i = 1; i <= totalCount; i++){\n            try {\n                const proposalResult = await (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.callReadOnlyFunction)({\n                    contractAddress,\n                    contractName,\n                    functionName: \"get-proposal\",\n                    functionArgs: [\n                        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.uintCV)(i)\n                    ],\n                    network,\n                    senderAddress: sender\n                });\n                // Proposal varsa listeye ekle\n                if (proposalResult.value !== null && proposalResult.value.data) {\n                    const proposalData = proposalResult.value.data;\n                    proposals.push({\n                        id: i,\n                        recipient: proposalData.to.value,\n                        amount: parseInt(proposalData.amount.value) / 1000000,\n                        confirmationCount: parseInt(proposalData[\"confirmation-count\"].value),\n                        executed: proposalData.executed.value,\n                        confirmations: proposalData.confirmations.value.map((p)=>p.value)\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error fetching proposal \".concat(i, \":\"), error);\n            // Belirli bir proposal alınamıyorsa devam et\n            }\n        }\n        return proposals;\n    } catch (error) {\n        console.error(\"Error fetching proposals:\", error);\n        return [];\n    }\n};\n// Tek bir proposal almak için yardımcı fonksiyon\nconst getProposal = async (proposalId, sender)=>{\n    try {\n        const result1 = await (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.callReadOnlyFunction)({\n            contractAddress,\n            contractName,\n            functionName: \"get-proposal\",\n            functionArgs: [\n                (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.uintCV)(parseInt(proposalId))\n            ],\n            network,\n            senderAddress: sender\n        });\n        if (result1.value && result1.value.data) {\n            const proposalData = result1.value.data;\n            return {\n                id: parseInt(proposalId),\n                recipient: proposalData.to.value,\n                amount: parseInt(proposalData.amount.value) / 1000000,\n                confirmationCount: parseInt(proposalData[\"confirmation-count\"].value),\n                executed: proposalData.executed.value,\n                confirmations: proposalData.confirmations.value.map((p)=>p.value)\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error fetching proposal:\", error);\n        return null;\n    }\n};\n// Threshold'u almak için yardımcı fonksiyon\nconst getThreshold = async (sender)=>{\n    try {\n        const result1 = await (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.callReadOnlyFunction)({\n            contractAddress,\n            contractName,\n            functionName: \"get-threshold\",\n            functionArgs: [],\n            network,\n            senderAddress: sender\n        });\n        return parseInt(result1.value.value);\n    } catch (error) {\n        console.error(\"Error fetching threshold:\", error);\n        return 0;\n    }\n};\n// Contract'ı initialize etmek için\nconst initializeContract = async (owner1, owner2, owner3, threshold)=>{\n    const functionArgs = [\n        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.standardPrincipalCV)(owner1),\n        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.standardPrincipalCV)(owner2),\n        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.standardPrincipalCV)(owner3),\n        (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.uintCV)(threshold)\n    ];\n    const options = {\n        contractAddress,\n        contractName,\n        functionName: \"initialize\",\n        functionArgs,\n        network,\n        postConditionMode: _stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.PostConditionMode.Allow,\n        onFinish: (data)=>console.log(\"Initialize transaction submitted:\", data),\n        onCancel: ()=>console.log(\"Initialize transaction canceled\")\n    };\n    await (0,_stacks_connect__WEBPACK_IMPORTED_MODULE_2__.openContractCall)(options);\n};\n// Bir principal'in owner olup olmadığını kontrol etmek için\nconst isOwner = async (principalAddress, sender)=>{\n    try {\n        const result1 = await (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.callReadOnlyFunction)({\n            contractAddress,\n            contractName,\n            functionName: \"is-owner-check\",\n            functionArgs: [\n                (0,_stacks_transactions__WEBPACK_IMPORTED_MODULE_1__.standardPrincipalCV)(principalAddress)\n            ],\n            network,\n            senderAddress: sender\n        });\n        return result1.value.value;\n    } catch (error) {\n        var _result;\n        console.error(\"Error checking owner status:\", error);\n        // Add this debugging before the return\n        console.log(\"Full result object:\", result);\n        console.log(\"result.value:\", (_result = result) === null || _result === void 0 ? void 0 : _result.value);\n        console.log(\"Result type:\", typeof result);\n        return false;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RSxPQUFPYSxPQUFPO1lBS2VFO1FBSjdCNUIsUUFBUTBCLEtBQUssQ0FBQyxnQ0FBZ0NBO1FBRTlDLHVDQUF1QztRQUN2QzFCLFFBQVFDLEdBQUcsQ0FBQyx1QkFBdUIyQjtRQUNuQzVCLFFBQVFDLEdBQUcsQ0FBQyxrQkFBaUIyQixVQUFBQSxvQkFBQUEsOEJBQUFBLFFBQVFmLEtBQUs7UUFDMUNiLFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0IsT0FBTzJCO1FBRW5DLE9BQU87SUFDVDtBQUNBLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9jb250cmFjdENhbGxzLmpzP2MyYmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xpYi9jb250cmFjdENhbGxzLmpzXHJcbmltcG9ydCB7XHJcbiAgY2FsbFJlYWRPbmx5RnVuY3Rpb24sXHJcbiAgc3RhbmRhcmRQcmluY2lwYWxDVixcclxuICB1aW50Q1YsXHJcbiAgc3RyaW5nVXRmOENWLFxyXG4gIFBvc3RDb25kaXRpb25Nb2RlLFxyXG59IGZyb20gJ0BzdGFja3MvdHJhbnNhY3Rpb25zJztcclxuaW1wb3J0IHsgU3RhY2tzVGVzdG5ldCB9IGZyb20gJ0BzdGFja3MvbmV0d29yayc7XHJcbmltcG9ydCB7IG9wZW5Db250cmFjdENhbGwgfSBmcm9tICdAc3RhY2tzL2Nvbm5lY3QnO1xyXG5cclxuY29uc3QgY29udHJhY3RBZGRyZXNzID0gXCJTVDM5NkQ2OUsyMUdWS1FWS1RHU1ZKOUo4R1JGMUE5TjNOQ0ZQNjlQN1wiOyAvLyBrZW5kaSBhZHJlc2luXHJcbmNvbnN0IGNvbnRyYWN0TmFtZSA9IFwibXVsdGktc2lnLXdhbGxldFwiO1xyXG5jb25zdCBuZXR3b3JrID0gbmV3IFN0YWNrc1Rlc3RuZXQoKTtcclxuXHJcbmV4cG9ydCBjb25zdCBwcm9wb3NlVHJhbnNhY3Rpb24gPSBhc3luYyAocmVjaXBpZW50LCBhbW91bnQpID0+IHtcclxuICBjb25zdCBpbnRlZ2VyQW1vdW50ID0gTnVtYmVyKGFtb3VudCk7XHJcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGludGVnZXJBbW91bnQpIHx8IGludGVnZXJBbW91bnQgPD0gMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQW1vdW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBmdW5jdGlvbkFyZ3MgPSBbXHJcbiAgICBzdGFuZGFyZFByaW5jaXBhbENWKHJlY2lwaWVudCksXHJcbiAgICB1aW50Q1YoaW50ZWdlckFtb3VudClcclxuICBdO1xyXG4gIFxyXG4gIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICBjb250cmFjdE5hbWUsXHJcbiAgICBmdW5jdGlvbk5hbWU6IFwicHJvcG9zZS10cmFuc2FjdGlvblwiLFxyXG4gICAgZnVuY3Rpb25BcmdzLFxyXG4gICAgbmV0d29yayxcclxuICAgIHBvc3RDb25kaXRpb25Nb2RlOiBQb3N0Q29uZGl0aW9uTW9kZS5BbGxvdyxcclxuICAgIG9uRmluaXNoOiBkYXRhID0+IGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBzdWJtaXR0ZWQ6JywgZGF0YSksXHJcbiAgICBvbkNhbmNlbDogKCkgPT4gY29uc29sZS5sb2coJ1RyYW5zYWN0aW9uIGNhbmNlbGVkJylcclxuICB9O1xyXG4gIFxyXG4gIGF3YWl0IG9wZW5Db250cmFjdENhbGwob3B0aW9ucyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY29uZmlybVRyYW5zYWN0aW9uID0gYXN5bmMgKHByb3Bvc2FsSWQpID0+IHtcclxuICAvLyBQcm9wb3NhbCBJRCB2YWxpZGFzeW9udVxyXG4gIGlmICghcHJvcG9zYWxJZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvcG9zYWwgSUQgaXMgcmVxdWlyZWRcIik7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IHBhcnNlZElkID0gcGFyc2VJbnQocHJvcG9zYWxJZCk7XHJcbiAgaWYgKGlzTmFOKHBhcnNlZElkKSB8fCBwYXJzZWRJZCA8PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3Bvc2FsIElELiBNdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyLlwiKTtcclxuICB9XHJcbiAgXHJcbiAgY29uc3QgZnVuY3Rpb25BcmdzID0gW3VpbnRDVihwYXJzZWRJZCldO1xyXG4gIFxyXG4gIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICBjb250cmFjdE5hbWUsXHJcbiAgICBmdW5jdGlvbk5hbWU6IFwiY29uZmlybS10cmFuc2FjdGlvblwiLFxyXG4gICAgZnVuY3Rpb25BcmdzLFxyXG4gICAgbmV0d29yayxcclxuICAgIHBvc3RDb25kaXRpb25Nb2RlOiBQb3N0Q29uZGl0aW9uTW9kZS5BbGxvdyxcclxuICAgIG9uRmluaXNoOiBkYXRhID0+IGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBzdWJtaXR0ZWQ6JywgZGF0YSksXHJcbiAgICBvbkNhbmNlbDogKCkgPT4gY29uc29sZS5sb2coJ1RyYW5zYWN0aW9uIGNhbmNlbGVkJylcclxuICB9O1xyXG4gIFxyXG4gIGF3YWl0IG9wZW5Db250cmFjdENhbGwob3B0aW9ucyk7XHJcbn07XHJcblxyXG4vLyBDb250cmFjdCfEsW7EsXrEsW4geWFwxLFzxLFuYSB1eWd1biBvbGFyYWsgZ8O8bmNlbGxlbm1pxZ8gZ2V0UHJvcG9zYWxzIGZvbmtzaXlvbnVcclxuZXhwb3J0IGNvbnN0IGdldFByb3Bvc2FscyA9IGFzeW5jIChzZW5kZXIpID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gw5ZuY2UgdG9wbGFtIHByb3Bvc2FsIHNhecSxc8SxbsSxIGFsXHJcbiAgICBjb25zdCBjb3VudFJlc3VsdCA9IGF3YWl0IGNhbGxSZWFkT25seUZ1bmN0aW9uKHtcclxuICAgICAgY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICBjb250cmFjdE5hbWUsXHJcbiAgICAgIGZ1bmN0aW9uTmFtZTogXCJnZXQtcHJvcG9zYWwtY291bnRcIixcclxuICAgICAgZnVuY3Rpb25BcmdzOiBbXSxcclxuICAgICAgbmV0d29yayxcclxuICAgICAgc2VuZGVyQWRkcmVzczogc2VuZGVyLFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGNvbnN0IHRvdGFsQ291bnQgPSBwYXJzZUludChjb3VudFJlc3VsdC52YWx1ZS52YWx1ZSk7XHJcbiAgICBjb25zdCBwcm9wb3NhbHMgPSBbXTtcclxuICAgIFxyXG4gICAgLy8gSGVyIHByb3Bvc2FsJ8SxIHRlayB0ZWsgw6dlayAoMSdkZW4gYmHFn2xheWFyYWsgw6fDvG5rw7wgSUQnbGVyIDEnZGVuIGJhxZ9sxLF5b3IpXHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0b3RhbENvdW50OyBpKyspIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwcm9wb3NhbFJlc3VsdCA9IGF3YWl0IGNhbGxSZWFkT25seUZ1bmN0aW9uKHtcclxuICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICAgIGNvbnRyYWN0TmFtZSxcclxuICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJnZXQtcHJvcG9zYWxcIixcclxuICAgICAgICAgIGZ1bmN0aW9uQXJnczogW3VpbnRDVihpKV0sXHJcbiAgICAgICAgICBuZXR3b3JrLFxyXG4gICAgICAgICAgc2VuZGVyQWRkcmVzczogc2VuZGVyLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFByb3Bvc2FsIHZhcnNhIGxpc3RleWUgZWtsZVxyXG4gICAgICAgIGlmIChwcm9wb3NhbFJlc3VsdC52YWx1ZSAhPT0gbnVsbCAmJiBwcm9wb3NhbFJlc3VsdC52YWx1ZS5kYXRhKSB7XHJcbiAgICAgICAgICBjb25zdCBwcm9wb3NhbERhdGEgPSBwcm9wb3NhbFJlc3VsdC52YWx1ZS5kYXRhO1xyXG4gICAgICAgICAgcHJvcG9zYWxzLnB1c2goe1xyXG4gICAgICAgICAgICBpZDogaSxcclxuICAgICAgICAgICAgcmVjaXBpZW50OiBwcm9wb3NhbERhdGEudG8udmFsdWUsXHJcbiAgICAgICAgICAgIGFtb3VudDogcGFyc2VJbnQocHJvcG9zYWxEYXRhLmFtb3VudC52YWx1ZSkgLyAxXzAwMF8wMDAsIC8vIG1pY3JvU1RYIOKGkiBTVFhcclxuICAgICAgICAgICAgY29uZmlybWF0aW9uQ291bnQ6IHBhcnNlSW50KHByb3Bvc2FsRGF0YVsnY29uZmlybWF0aW9uLWNvdW50J10udmFsdWUpLFxyXG4gICAgICAgICAgICBleGVjdXRlZDogcHJvcG9zYWxEYXRhLmV4ZWN1dGVkLnZhbHVlLFxyXG4gICAgICAgICAgICBjb25maXJtYXRpb25zOiBwcm9wb3NhbERhdGEuY29uZmlybWF0aW9ucy52YWx1ZS5tYXAocCA9PiBwLnZhbHVlKVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHByb3Bvc2FsICR7aX06YCwgZXJyb3IpO1xyXG4gICAgICAgIC8vIEJlbGlybGkgYmlyIHByb3Bvc2FsIGFsxLFuYW3EsXlvcnNhIGRldmFtIGV0XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHByb3Bvc2FscztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHByb3Bvc2FsczpcIiwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFRlayBiaXIgcHJvcG9zYWwgYWxtYWsgacOnaW4geWFyZMSxbWPEsSBmb25rc2l5b25cclxuZXhwb3J0IGNvbnN0IGdldFByb3Bvc2FsID0gYXN5bmMgKHByb3Bvc2FsSWQsIHNlbmRlcikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWxsUmVhZE9ubHlGdW5jdGlvbih7XHJcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgY29udHJhY3ROYW1lLFxyXG4gICAgICBmdW5jdGlvbk5hbWU6IFwiZ2V0LXByb3Bvc2FsXCIsXHJcbiAgICAgIGZ1bmN0aW9uQXJnczogW3VpbnRDVihwYXJzZUludChwcm9wb3NhbElkKSldLFxyXG4gICAgICBuZXR3b3JrLFxyXG4gICAgICBzZW5kZXJBZGRyZXNzOiBzZW5kZXIsXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgaWYgKHJlc3VsdC52YWx1ZSAmJiByZXN1bHQudmFsdWUuZGF0YSkge1xyXG4gICAgICBjb25zdCBwcm9wb3NhbERhdGEgPSByZXN1bHQudmFsdWUuZGF0YTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogcGFyc2VJbnQocHJvcG9zYWxJZCksXHJcbiAgICAgICAgcmVjaXBpZW50OiBwcm9wb3NhbERhdGEudG8udmFsdWUsXHJcbiAgICAgICAgYW1vdW50OiBwYXJzZUludChwcm9wb3NhbERhdGEuYW1vdW50LnZhbHVlKSAvIDFfMDAwXzAwMCxcclxuICAgICAgICBjb25maXJtYXRpb25Db3VudDogcGFyc2VJbnQocHJvcG9zYWxEYXRhWydjb25maXJtYXRpb24tY291bnQnXS52YWx1ZSksXHJcbiAgICAgICAgZXhlY3V0ZWQ6IHByb3Bvc2FsRGF0YS5leGVjdXRlZC52YWx1ZSxcclxuICAgICAgICBjb25maXJtYXRpb25zOiBwcm9wb3NhbERhdGEuY29uZmlybWF0aW9ucy52YWx1ZS5tYXAocCA9PiBwLnZhbHVlKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHByb3Bvc2FsOlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn07XHJcblxyXG4vLyBUaHJlc2hvbGQndSBhbG1hayBpw6dpbiB5YXJkxLFtY8SxIGZvbmtzaXlvblxyXG5leHBvcnQgY29uc3QgZ2V0VGhyZXNob2xkID0gYXN5bmMgKHNlbmRlcikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWxsUmVhZE9ubHlGdW5jdGlvbih7XHJcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgY29udHJhY3ROYW1lLFxyXG4gICAgICBmdW5jdGlvbk5hbWU6IFwiZ2V0LXRocmVzaG9sZFwiLFxyXG4gICAgICBmdW5jdGlvbkFyZ3M6IFtdLFxyXG4gICAgICBuZXR3b3JrLFxyXG4gICAgICBzZW5kZXJBZGRyZXNzOiBzZW5kZXIsXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHBhcnNlSW50KHJlc3VsdC52YWx1ZS52YWx1ZSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyB0aHJlc2hvbGQ6XCIsIGVycm9yKTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIENvbnRyYWN0J8SxIGluaXRpYWxpemUgZXRtZWsgacOnaW5cclxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVDb250cmFjdCA9IGFzeW5jIChvd25lcjEsIG93bmVyMiwgb3duZXIzLCB0aHJlc2hvbGQpID0+IHtcclxuICBjb25zdCBmdW5jdGlvbkFyZ3MgPSBbXHJcbiAgICBzdGFuZGFyZFByaW5jaXBhbENWKG93bmVyMSksXHJcbiAgICBzdGFuZGFyZFByaW5jaXBhbENWKG93bmVyMiksXHJcbiAgICBzdGFuZGFyZFByaW5jaXBhbENWKG93bmVyMyksXHJcbiAgICB1aW50Q1YodGhyZXNob2xkKVxyXG4gIF07XHJcbiAgXHJcbiAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgIGNvbnRyYWN0QWRkcmVzcyxcclxuICAgIGNvbnRyYWN0TmFtZSxcclxuICAgIGZ1bmN0aW9uTmFtZTogXCJpbml0aWFsaXplXCIsXHJcbiAgICBmdW5jdGlvbkFyZ3MsXHJcbiAgICBuZXR3b3JrLFxyXG4gICAgcG9zdENvbmRpdGlvbk1vZGU6IFBvc3RDb25kaXRpb25Nb2RlLkFsbG93LFxyXG4gICAgb25GaW5pc2g6IGRhdGEgPT4gY29uc29sZS5sb2coJ0luaXRpYWxpemUgdHJhbnNhY3Rpb24gc3VibWl0dGVkOicsIGRhdGEpLFxyXG4gICAgb25DYW5jZWw6ICgpID0+IGNvbnNvbGUubG9nKCdJbml0aWFsaXplIHRyYW5zYWN0aW9uIGNhbmNlbGVkJylcclxuICB9O1xyXG4gIFxyXG4gIGF3YWl0IG9wZW5Db250cmFjdENhbGwob3B0aW9ucyk7XHJcbn07XHJcblxyXG4vLyBCaXIgcHJpbmNpcGFsJ2luIG93bmVyIG9sdXAgb2xtYWTEscSfxLFuxLEga29udHJvbCBldG1layBpw6dpblxyXG5leHBvcnQgY29uc3QgaXNPd25lciA9IGFzeW5jIChwcmluY2lwYWxBZGRyZXNzLCBzZW5kZXIpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbFJlYWRPbmx5RnVuY3Rpb24oe1xyXG4gICAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICAgIGNvbnRyYWN0TmFtZSxcclxuICAgICAgZnVuY3Rpb25OYW1lOiBcImlzLW93bmVyLWNoZWNrXCIsXHJcbiAgICAgIGZ1bmN0aW9uQXJnczogW3N0YW5kYXJkUHJpbmNpcGFsQ1YocHJpbmNpcGFsQWRkcmVzcyldLFxyXG4gICAgICBuZXR3b3JrLFxyXG4gICAgICBzZW5kZXJBZGRyZXNzOiBzZW5kZXIsXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICByZXR1cm4gcmVzdWx0LnZhbHVlLnZhbHVlO1xyXG59IGNhdGNoIChlcnJvcikge1xyXG4gIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjaGVja2luZyBvd25lciBzdGF0dXM6XCIsIGVycm9yKTtcclxuICBcclxuICAvLyBBZGQgdGhpcyBkZWJ1Z2dpbmcgYmVmb3JlIHRoZSByZXR1cm5cclxuICBjb25zb2xlLmxvZyhcIkZ1bGwgcmVzdWx0IG9iamVjdDpcIiwgcmVzdWx0KTtcclxuICBjb25zb2xlLmxvZyhcInJlc3VsdC52YWx1ZTpcIiwgcmVzdWx0Py52YWx1ZSk7XHJcbiAgY29uc29sZS5sb2coXCJSZXN1bHQgdHlwZTpcIiwgdHlwZW9mIHJlc3VsdCk7XHJcbiAgXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbn07Il0sIm5hbWVzIjpbImNhbGxSZWFkT25seUZ1bmN0aW9uIiwic3RhbmRhcmRQcmluY2lwYWxDViIsInVpbnRDViIsInN0cmluZ1V0ZjhDViIsIlBvc3RDb25kaXRpb25Nb2RlIiwiU3RhY2tzVGVzdG5ldCIsIm9wZW5Db250cmFjdENhbGwiLCJjb250cmFjdEFkZHJlc3MiLCJjb250cmFjdE5hbWUiLCJuZXR3b3JrIiwicHJvcG9zZVRyYW5zYWN0aW9uIiwicmVjaXBpZW50IiwiYW1vdW50IiwiaW50ZWdlckFtb3VudCIsIk51bWJlciIsImlzSW50ZWdlciIsIkVycm9yIiwiZnVuY3Rpb25BcmdzIiwib3B0aW9ucyIsImZ1bmN0aW9uTmFtZSIsInBvc3RDb25kaXRpb25Nb2RlIiwiQWxsb3ciLCJvbkZpbmlzaCIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwib25DYW5jZWwiLCJjb25maXJtVHJhbnNhY3Rpb24iLCJwcm9wb3NhbElkIiwicGFyc2VkSWQiLCJwYXJzZUludCIsImlzTmFOIiwiZ2V0UHJvcG9zYWxzIiwic2VuZGVyIiwiY291bnRSZXN1bHQiLCJzZW5kZXJBZGRyZXNzIiwidG90YWxDb3VudCIsInZhbHVlIiwicHJvcG9zYWxzIiwiaSIsInByb3Bvc2FsUmVzdWx0IiwicHJvcG9zYWxEYXRhIiwicHVzaCIsImlkIiwidG8iLCJjb25maXJtYXRpb25Db3VudCIsImV4ZWN1dGVkIiwiY29uZmlybWF0aW9ucyIsIm1hcCIsInAiLCJlcnJvciIsImdldFByb3Bvc2FsIiwicmVzdWx0IiwiZ2V0VGhyZXNob2xkIiwiaW5pdGlhbGl6ZUNvbnRyYWN0Iiwib3duZXIxIiwib3duZXIyIiwib3duZXIzIiwidGhyZXNob2xkIiwiaXNPd25lciIsInByaW5jaXBhbEFkZHJlc3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib/contractCalls.js\n"));

/***/ })

});